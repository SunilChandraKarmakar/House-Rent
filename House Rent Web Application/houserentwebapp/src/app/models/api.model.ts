//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AccountClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    registration(command: RegistrationCommand): Promise<UserModel> {
        let url_ = this.baseUrl + "/api/Account/Registration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegistration(_response);
        });
    }

    protected processRegistration(response: Response): Promise<UserModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    login(command: LoginCommand): Promise<UserModel> {
        let url_ = this.baseUrl + "/api/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<UserModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }
}

export class AddressClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(): Promise<AddressGridModel[]> {
        let url_ = this.baseUrl + "/api/Address/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<AddressGridModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AddressGridModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AddressGridModel[]>(null as any);
    }

    get(id: number): Promise<AddressViewModel> {
        let url_ = this.baseUrl + "/api/Address/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<AddressViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddressViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AddressViewModel>(null as any);
    }

    upsert(command: UpsertAddressCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Address/Upsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpsert(_response);
        });
    }

    protected processUpsert(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    delete(id: number): Promise<number> {
        let url_ = this.baseUrl + "/api/Address/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }
}

export class CityClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(): Promise<CityGridModel[]> {
        let url_ = this.baseUrl + "/api/City/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<CityGridModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityGridModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CityGridModel[]>(null as any);
    }

    get(id: number): Promise<CityViewModel> {
        let url_ = this.baseUrl + "/api/City/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<CityViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CityViewModel>(null as any);
    }

    upsert(command: UpsertCityCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/City/Upsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpsert(_response);
        });
    }

    protected processUpsert(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    delete(id: number): Promise<number> {
        let url_ = this.baseUrl + "/api/City/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }
}

export class CountryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(): Promise<CountryGridModel[]> {
        let url_ = this.baseUrl + "/api/Country/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<CountryGridModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryGridModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountryGridModel[]>(null as any);
    }

    get(id: number): Promise<CountryViewModel> {
        let url_ = this.baseUrl + "/api/Country/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<CountryViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CountryViewModel>(null as any);
    }

    upsert(command: UpsertCountryCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Country/Upsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpsert(_response);
        });
    }

    protected processUpsert(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    delete(id: number): Promise<number> {
        let url_ = this.baseUrl + "/api/Country/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }
}

export class FurnishingTypeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(): Promise<FurnishingTypeGridModel[]> {
        let url_ = this.baseUrl + "/api/FurnishingType/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<FurnishingTypeGridModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FurnishingTypeGridModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FurnishingTypeGridModel[]>(null as any);
    }

    get(id: number): Promise<FurnishingTypeViewModel> {
        let url_ = this.baseUrl + "/api/FurnishingType/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FurnishingTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FurnishingTypeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FurnishingTypeViewModel>(null as any);
    }

    upsert(command: UpsertFurnishingTypeCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/FurnishingType/Upsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpsert(_response);
        });
    }

    protected processUpsert(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    delete(id: number): Promise<number> {
        let url_ = this.baseUrl + "/api/FurnishingType/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }
}

export class PropertyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(): Promise<PropertyGridModel[]> {
        let url_ = this.baseUrl + "/api/Property/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PropertyGridModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PropertyGridModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PropertyGridModel[]>(null as any);
    }

    get(id: number): Promise<PropertyViewModel> {
        let url_ = this.baseUrl + "/api/Property/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<PropertyViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PropertyViewModel>(null as any);
    }

    upsert(command: UpsertPropertyCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Property/Upsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpsert(_response);
        });
    }

    protected processUpsert(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    delete(id: number): Promise<number> {
        let url_ = this.baseUrl + "/api/Property/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }
}

export class PropertyTypeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(): Promise<PropertyTypeGridModel[]> {
        let url_ = this.baseUrl + "/api/PropertyType/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PropertyTypeGridModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PropertyTypeGridModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PropertyTypeGridModel[]>(null as any);
    }

    get(id: number): Promise<PropertyTypeViewModel> {
        let url_ = this.baseUrl + "/api/PropertyType/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<PropertyTypeViewModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyTypeViewModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PropertyTypeViewModel>(null as any);
    }

    upsert(command: UpsertPropertyTypeCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/PropertyType/Upsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpsert(_response);
        });
    }

    protected processUpsert(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    delete(id: number): Promise<number> {
        let url_ = this.baseUrl + "/api/PropertyType/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }
}

export class UserModel implements IUserModel {
    id!: string;
    fullName!: string;
    userName!: string;
    email!: string;
    token!: string;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["token"] = this.token;
        return data;
    }
}

export interface IUserModel {
    id: string;
    fullName: string;
    userName: string;
    email: string;
    token: string;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class RegisterModel implements IRegisterModel {
    fullName!: string;
    userName!: string;
    phoneNumber!: string;
    email!: string;
    password!: string;
    confirmPassword!: string;

    constructor(data?: IRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.userName = _data["userName"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): RegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["userName"] = this.userName;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IRegisterModel {
    fullName: string;
    userName: string;
    phoneNumber: string;
    email: string;
    password: string;
    confirmPassword: string;
}

export class RegistrationCommand extends RegisterModel implements IRegistrationCommand {

    constructor(data?: IRegistrationCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): RegistrationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IRegistrationCommand extends IRegisterModel {
}

export class LoginModel implements ILoginModel {
    userName!: string;
    password!: string;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginModel {
    userName: string;
    password: string;
}

export class LoginCommand extends LoginModel implements ILoginCommand {

    constructor(data?: ILoginCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ILoginCommand extends ILoginModel {
}

export class AddressGridModel implements IAddressGridModel {
    id!: number;
    addressLineOne!: string;
    addressLineTwo!: string;
    countryName!: string;
    cityName!: string;

    constructor(data?: IAddressGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.addressLineOne = _data["addressLineOne"];
            this.addressLineTwo = _data["addressLineTwo"];
            this.countryName = _data["countryName"];
            this.cityName = _data["cityName"];
        }
    }

    static fromJS(data: any): AddressGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddressGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["addressLineOne"] = this.addressLineOne;
        data["addressLineTwo"] = this.addressLineTwo;
        data["countryName"] = this.countryName;
        data["cityName"] = this.cityName;
        return data;
    }
}

export interface IAddressGridModel {
    id: number;
    addressLineOne: string;
    addressLineTwo: string;
    countryName: string;
    cityName: string;
}

export class AddressViewModel implements IAddressViewModel {
    model!: AddressModel;
    gridModel!: AddressGridModel;
    optionsDataSources!: any;

    constructor(data?: IAddressViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.model = new AddressModel();
            this.gridModel = new AddressGridModel();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.model = _data["model"] ? AddressModel.fromJS(_data["model"]) : new AddressModel();
            this.gridModel = _data["gridModel"] ? AddressGridModel.fromJS(_data["gridModel"]) : new AddressGridModel();
            this.optionsDataSources = _data["optionsDataSources"];
        }
    }

    static fromJS(data: any): AddressViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddressViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        data["gridModel"] = this.gridModel ? this.gridModel.toJSON() : <any>undefined;
        data["optionsDataSources"] = this.optionsDataSources;
        return data;
    }
}

export interface IAddressViewModel {
    model: AddressModel;
    gridModel: AddressGridModel;
    optionsDataSources: any;
}

export class AddressModel implements IAddressModel {
    id!: number;
    addressLineOne!: string;
    addressLineTwo!: string;
    countryId!: number;
    cityId!: number;

    constructor(data?: IAddressModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.addressLineOne = _data["addressLineOne"];
            this.addressLineTwo = _data["addressLineTwo"];
            this.countryId = _data["countryId"];
            this.cityId = _data["cityId"];
        }
    }

    static fromJS(data: any): AddressModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddressModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["addressLineOne"] = this.addressLineOne;
        data["addressLineTwo"] = this.addressLineTwo;
        data["countryId"] = this.countryId;
        data["cityId"] = this.cityId;
        return data;
    }
}

export interface IAddressModel {
    id: number;
    addressLineOne: string;
    addressLineTwo: string;
    countryId: number;
    cityId: number;
}

export class UpsertAddressCommand extends AddressModel implements IUpsertAddressCommand {

    constructor(data?: IUpsertAddressCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpsertAddressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertAddressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpsertAddressCommand extends IAddressModel {
}

export class CityGridModel implements ICityGridModel {
    id!: number;
    name!: string;
    countryName!: string;

    constructor(data?: ICityGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): CityGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new CityGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface ICityGridModel {
    id: number;
    name: string;
    countryName: string;
}

export class CityViewModel implements ICityViewModel {
    model!: CityModel;
    gridModel!: CityGridModel;
    optionsDataSources!: any;

    constructor(data?: ICityViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.model = new CityModel();
            this.gridModel = new CityGridModel();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.model = _data["model"] ? CityModel.fromJS(_data["model"]) : new CityModel();
            this.gridModel = _data["gridModel"] ? CityGridModel.fromJS(_data["gridModel"]) : new CityGridModel();
            this.optionsDataSources = _data["optionsDataSources"];
        }
    }

    static fromJS(data: any): CityViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CityViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        data["gridModel"] = this.gridModel ? this.gridModel.toJSON() : <any>undefined;
        data["optionsDataSources"] = this.optionsDataSources;
        return data;
    }
}

export interface ICityViewModel {
    model: CityModel;
    gridModel: CityGridModel;
    optionsDataSources: any;
}

export class CityModel implements ICityModel {
    id!: number;
    name!: string;
    countryId!: number;

    constructor(data?: ICityModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.countryId = _data["countryId"];
        }
    }

    static fromJS(data: any): CityModel {
        data = typeof data === 'object' ? data : {};
        let result = new CityModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["countryId"] = this.countryId;
        return data;
    }
}

export interface ICityModel {
    id: number;
    name: string;
    countryId: number;
}

export class UpsertCityCommand extends CityModel implements IUpsertCityCommand {

    constructor(data?: IUpsertCityCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpsertCityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertCityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpsertCityCommand extends ICityModel {
}

export class CountryGridModel implements ICountryGridModel {
    id!: number;
    name!: string;

    constructor(data?: ICountryGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryGridModel {
    id: number;
    name: string;
}

export class CountryViewModel implements ICountryViewModel {
    model!: CountryModel;
    gridModel!: CountryGridModel;
    optionsDataSources!: any;

    constructor(data?: ICountryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.model = new CountryModel();
            this.gridModel = new CountryGridModel();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.model = _data["model"] ? CountryModel.fromJS(_data["model"]) : new CountryModel();
            this.gridModel = _data["gridModel"] ? CountryGridModel.fromJS(_data["gridModel"]) : new CountryGridModel();
            this.optionsDataSources = _data["optionsDataSources"];
        }
    }

    static fromJS(data: any): CountryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        data["gridModel"] = this.gridModel ? this.gridModel.toJSON() : <any>undefined;
        data["optionsDataSources"] = this.optionsDataSources;
        return data;
    }
}

export interface ICountryViewModel {
    model: CountryModel;
    gridModel: CountryGridModel;
    optionsDataSources: any;
}

export class CountryModel implements ICountryModel {
    id!: number;
    name!: string;

    constructor(data?: ICountryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICountryModel {
    id: number;
    name: string;
}

export class UpsertCountryCommand extends CountryModel implements IUpsertCountryCommand {

    constructor(data?: IUpsertCountryCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpsertCountryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertCountryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpsertCountryCommand extends ICountryModel {
}

export class FurnishingTypeGridModel implements IFurnishingTypeGridModel {
    id!: number;
    name!: string;

    constructor(data?: IFurnishingTypeGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FurnishingTypeGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new FurnishingTypeGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IFurnishingTypeGridModel {
    id: number;
    name: string;
}

export class FurnishingTypeViewModel implements IFurnishingTypeViewModel {
    model!: FurnishingTypeModel;
    gridModel!: FurnishingTypeGridModel;

    constructor(data?: IFurnishingTypeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.model = new FurnishingTypeModel();
            this.gridModel = new FurnishingTypeGridModel();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.model = _data["model"] ? FurnishingTypeModel.fromJS(_data["model"]) : new FurnishingTypeModel();
            this.gridModel = _data["gridModel"] ? FurnishingTypeGridModel.fromJS(_data["gridModel"]) : new FurnishingTypeGridModel();
        }
    }

    static fromJS(data: any): FurnishingTypeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new FurnishingTypeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        data["gridModel"] = this.gridModel ? this.gridModel.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFurnishingTypeViewModel {
    model: FurnishingTypeModel;
    gridModel: FurnishingTypeGridModel;
}

export class FurnishingTypeModel implements IFurnishingTypeModel {
    id!: number;
    name!: string;

    constructor(data?: IFurnishingTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FurnishingTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new FurnishingTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IFurnishingTypeModel {
    id: number;
    name: string;
}

export class UpsertFurnishingTypeCommand extends FurnishingTypeModel implements IUpsertFurnishingTypeCommand {

    constructor(data?: IUpsertFurnishingTypeCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpsertFurnishingTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertFurnishingTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpsertFurnishingTypeCommand extends IFurnishingTypeModel {
}

export class PropertyGridModel implements IPropertyGridModel {
    id!: number;
    name!: string;
    sellRent!: number;
    propertyTypeName!: string;
    furnishingTypeName!: string;
    bhk!: number;
    price!: number;
    buildArea!: number;
    carpetArea!: number;
    floorNo!: number;
    totalFloor!: number;
    isReadyToMove!: boolean;
    mainEntrance!: string;
    security!: number;
    isGated!: boolean;
    maintenence!: number;
    estPossessionOn?: Date | undefined;
    postedOn?: Date | undefined;
    age!: number;
    description!: string;
    userName!: string;
    address!: Address;

    constructor(data?: IPropertyGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.address = new Address();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sellRent = _data["sellRent"];
            this.propertyTypeName = _data["propertyTypeName"];
            this.furnishingTypeName = _data["furnishingTypeName"];
            this.bhk = _data["bhk"];
            this.price = _data["price"];
            this.buildArea = _data["buildArea"];
            this.carpetArea = _data["carpetArea"];
            this.floorNo = _data["floorNo"];
            this.totalFloor = _data["totalFloor"];
            this.isReadyToMove = _data["isReadyToMove"];
            this.mainEntrance = _data["mainEntrance"];
            this.security = _data["security"];
            this.isGated = _data["isGated"];
            this.maintenence = _data["maintenence"];
            this.estPossessionOn = _data["estPossessionOn"] ? new Date(_data["estPossessionOn"].toString()) : <any>undefined;
            this.postedOn = _data["postedOn"] ? new Date(_data["postedOn"].toString()) : <any>undefined;
            this.age = _data["age"];
            this.description = _data["description"];
            this.userName = _data["userName"];
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : new Address();
        }
    }

    static fromJS(data: any): PropertyGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sellRent"] = this.sellRent;
        data["propertyTypeName"] = this.propertyTypeName;
        data["furnishingTypeName"] = this.furnishingTypeName;
        data["bhk"] = this.bhk;
        data["price"] = this.price;
        data["buildArea"] = this.buildArea;
        data["carpetArea"] = this.carpetArea;
        data["floorNo"] = this.floorNo;
        data["totalFloor"] = this.totalFloor;
        data["isReadyToMove"] = this.isReadyToMove;
        data["mainEntrance"] = this.mainEntrance;
        data["security"] = this.security;
        data["isGated"] = this.isGated;
        data["maintenence"] = this.maintenence;
        data["estPossessionOn"] = this.estPossessionOn ? this.estPossessionOn.toISOString() : <any>undefined;
        data["postedOn"] = this.postedOn ? this.postedOn.toISOString() : <any>undefined;
        data["age"] = this.age;
        data["description"] = this.description;
        data["userName"] = this.userName;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPropertyGridModel {
    id: number;
    name: string;
    sellRent: number;
    propertyTypeName: string;
    furnishingTypeName: string;
    bhk: number;
    price: number;
    buildArea: number;
    carpetArea: number;
    floorNo: number;
    totalFloor: number;
    isReadyToMove: boolean;
    mainEntrance: string;
    security: number;
    isGated: boolean;
    maintenence: number;
    estPossessionOn?: Date | undefined;
    postedOn?: Date | undefined;
    age: number;
    description: string;
    userName: string;
    address: Address;
}

export class Address implements IAddress {
    id!: number;
    addressLineOne!: string;
    addressLineTwo!: string;
    countryId!: number;
    cityId!: number;
    isDeleted!: boolean;
    deletedDateTime?: Date | undefined;
    city!: City;
    country!: Country;
    properties!: Property[];

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.city = new City();
            this.country = new Country();
            this.properties = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.addressLineOne = _data["addressLineOne"];
            this.addressLineTwo = _data["addressLineTwo"];
            this.countryId = _data["countryId"];
            this.cityId = _data["cityId"];
            this.isDeleted = _data["isDeleted"];
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>undefined;
            this.city = _data["city"] ? City.fromJS(_data["city"]) : new City();
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : new Country();
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["addressLineOne"] = this.addressLineOne;
        data["addressLineTwo"] = this.addressLineTwo;
        data["countryId"] = this.countryId;
        data["cityId"] = this.cityId;
        data["isDeleted"] = this.isDeleted;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>undefined;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAddress {
    id: number;
    addressLineOne: string;
    addressLineTwo: string;
    countryId: number;
    cityId: number;
    isDeleted: boolean;
    deletedDateTime?: Date | undefined;
    city: City;
    country: Country;
    properties: Property[];
}

export class City implements ICity {
    id!: number;
    name!: string;
    countryId!: number;
    isDeleted!: boolean;
    deletedDateTime?: Date | undefined;
    country!: Country;
    address!: Address[];

    constructor(data?: ICity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.country = new Country();
            this.address = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.countryId = _data["countryId"];
            this.isDeleted = _data["isDeleted"];
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>undefined;
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : new Country();
            if (Array.isArray(_data["address"])) {
                this.address = [] as any;
                for (let item of _data["address"])
                    this.address!.push(Address.fromJS(item));
            }
        }
    }

    static fromJS(data: any): City {
        data = typeof data === 'object' ? data : {};
        let result = new City();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["countryId"] = this.countryId;
        data["isDeleted"] = this.isDeleted;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>undefined;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        if (Array.isArray(this.address)) {
            data["address"] = [];
            for (let item of this.address)
                data["address"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICity {
    id: number;
    name: string;
    countryId: number;
    isDeleted: boolean;
    deletedDateTime?: Date | undefined;
    country: Country;
    address: Address[];
}

export class Country implements ICountry {
    id!: number;
    name!: string;
    isDeleted!: boolean;
    deletedDateTime?: Date | undefined;
    addresses!: Address[];
    cities!: City[];

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.addresses = [];
            this.cities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDeleted = _data["isDeleted"];
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(Address.fromJS(item));
            }
            if (Array.isArray(_data["cities"])) {
                this.cities = [] as any;
                for (let item of _data["cities"])
                    this.cities!.push(City.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDeleted"] = this.isDeleted;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>undefined;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.cities)) {
            data["cities"] = [];
            for (let item of this.cities)
                data["cities"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICountry {
    id: number;
    name: string;
    isDeleted: boolean;
    deletedDateTime?: Date | undefined;
    addresses: Address[];
    cities: City[];
}

export class Property implements IProperty {
    id!: number;
    name!: string;
    sellRent!: number;
    propertyTypeId!: number;
    furnishingTypeId!: number;
    bhk!: number;
    price!: number;
    buildArea!: number;
    carpetArea!: number;
    floorNo!: number;
    totalFloor!: number;
    addressId!: number;
    isReadyToMove!: boolean;
    mainEntrance!: string;
    security!: number;
    isGated!: boolean;
    maintenence!: number;
    estPossessionOn?: Date | undefined;
    postedOn?: Date | undefined;
    age!: number;
    description!: string;
    userId!: string;
    isDeleted!: boolean;
    deletedDateTime?: Date | undefined;
    address!: Address;
    furnishingType!: FurnishingType;
    propertyType!: PropertyType;
    user!: User;
    photos!: Photo[];

    constructor(data?: IProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.address = new Address();
            this.furnishingType = new FurnishingType();
            this.propertyType = new PropertyType();
            this.user = new User();
            this.photos = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sellRent = _data["sellRent"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.furnishingTypeId = _data["furnishingTypeId"];
            this.bhk = _data["bhk"];
            this.price = _data["price"];
            this.buildArea = _data["buildArea"];
            this.carpetArea = _data["carpetArea"];
            this.floorNo = _data["floorNo"];
            this.totalFloor = _data["totalFloor"];
            this.addressId = _data["addressId"];
            this.isReadyToMove = _data["isReadyToMove"];
            this.mainEntrance = _data["mainEntrance"];
            this.security = _data["security"];
            this.isGated = _data["isGated"];
            this.maintenence = _data["maintenence"];
            this.estPossessionOn = _data["estPossessionOn"] ? new Date(_data["estPossessionOn"].toString()) : <any>undefined;
            this.postedOn = _data["postedOn"] ? new Date(_data["postedOn"].toString()) : <any>undefined;
            this.age = _data["age"];
            this.description = _data["description"];
            this.userId = _data["userId"];
            this.isDeleted = _data["isDeleted"];
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>undefined;
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : new Address();
            this.furnishingType = _data["furnishingType"] ? FurnishingType.fromJS(_data["furnishingType"]) : new FurnishingType();
            this.propertyType = _data["propertyType"] ? PropertyType.fromJS(_data["propertyType"]) : new PropertyType();
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            if (Array.isArray(_data["photos"])) {
                this.photos = [] as any;
                for (let item of _data["photos"])
                    this.photos!.push(Photo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Property {
        data = typeof data === 'object' ? data : {};
        let result = new Property();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sellRent"] = this.sellRent;
        data["propertyTypeId"] = this.propertyTypeId;
        data["furnishingTypeId"] = this.furnishingTypeId;
        data["bhk"] = this.bhk;
        data["price"] = this.price;
        data["buildArea"] = this.buildArea;
        data["carpetArea"] = this.carpetArea;
        data["floorNo"] = this.floorNo;
        data["totalFloor"] = this.totalFloor;
        data["addressId"] = this.addressId;
        data["isReadyToMove"] = this.isReadyToMove;
        data["mainEntrance"] = this.mainEntrance;
        data["security"] = this.security;
        data["isGated"] = this.isGated;
        data["maintenence"] = this.maintenence;
        data["estPossessionOn"] = this.estPossessionOn ? this.estPossessionOn.toISOString() : <any>undefined;
        data["postedOn"] = this.postedOn ? this.postedOn.toISOString() : <any>undefined;
        data["age"] = this.age;
        data["description"] = this.description;
        data["userId"] = this.userId;
        data["isDeleted"] = this.isDeleted;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["furnishingType"] = this.furnishingType ? this.furnishingType.toJSON() : <any>undefined;
        data["propertyType"] = this.propertyType ? this.propertyType.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.photos)) {
            data["photos"] = [];
            for (let item of this.photos)
                data["photos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProperty {
    id: number;
    name: string;
    sellRent: number;
    propertyTypeId: number;
    furnishingTypeId: number;
    bhk: number;
    price: number;
    buildArea: number;
    carpetArea: number;
    floorNo: number;
    totalFloor: number;
    addressId: number;
    isReadyToMove: boolean;
    mainEntrance: string;
    security: number;
    isGated: boolean;
    maintenence: number;
    estPossessionOn?: Date | undefined;
    postedOn?: Date | undefined;
    age: number;
    description: string;
    userId: string;
    isDeleted: boolean;
    deletedDateTime?: Date | undefined;
    address: Address;
    furnishingType: FurnishingType;
    propertyType: PropertyType;
    user: User;
    photos: Photo[];
}

export class FurnishingType implements IFurnishingType {
    id!: number;
    name!: string;
    isDeleted!: boolean;
    deletedDateTime?: Date | undefined;
    properties!: Property[];

    constructor(data?: IFurnishingType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.properties = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDeleted = _data["isDeleted"];
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FurnishingType {
        data = typeof data === 'object' ? data : {};
        let result = new FurnishingType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDeleted"] = this.isDeleted;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>undefined;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFurnishingType {
    id: number;
    name: string;
    isDeleted: boolean;
    deletedDateTime?: Date | undefined;
    properties: Property[];
}

export class PropertyType implements IPropertyType {
    id!: number;
    name!: string;
    isDeleted!: boolean;
    deletedDateTime?: Date | undefined;
    properties!: Property[];

    constructor(data?: IPropertyType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.properties = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDeleted = _data["isDeleted"];
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PropertyType {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDeleted"] = this.isDeleted;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>undefined;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPropertyType {
    id: number;
    name: string;
    isDeleted: boolean;
    deletedDateTime?: Date | undefined;
    properties: Property[];
}

export class IdentityUserOfString implements IIdentityUserOfString {
    id!: string;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed!: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed!: boolean;
    twoFactorEnabled!: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled!: boolean;
    accessFailedCount!: number;

    constructor(data?: IIdentityUserOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUserOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IIdentityUserOfString {
    id: string;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled: boolean;
    accessFailedCount: number;
}

export class IdentityUser extends IdentityUserOfString implements IIdentityUser {

    constructor(data?: IIdentityUser) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): IdentityUser {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIdentityUser extends IIdentityUserOfString {
}

export class User extends IdentityUser implements IUser {
    fullName!: string;
    createdTime!: Date;
    lastModifiedTime!: Date;
    properties!: Property[];

    constructor(data?: IUser) {
        super(data);
        if (!data) {
            this.properties = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fullName = _data["fullName"];
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.lastModifiedTime = _data["lastModifiedTime"] ? new Date(_data["lastModifiedTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["lastModifiedTime"] = this.lastModifiedTime ? this.lastModifiedTime.toISOString() : <any>undefined;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IUser extends IIdentityUser {
    fullName: string;
    createdTime: Date;
    lastModifiedTime: Date;
    properties: Property[];
}

export class Photo implements IPhoto {
    id!: number;
    url!: string;
    propertyId!: number;
    isDefault!: boolean;
    isDeleted!: boolean;
    deletedDateTime?: Date | undefined;
    property!: Property;

    constructor(data?: IPhoto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.property = new Property();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.propertyId = _data["propertyId"];
            this.isDefault = _data["isDefault"];
            this.isDeleted = _data["isDeleted"];
            this.deletedDateTime = _data["deletedDateTime"] ? new Date(_data["deletedDateTime"].toString()) : <any>undefined;
            this.property = _data["property"] ? Property.fromJS(_data["property"]) : new Property();
        }
    }

    static fromJS(data: any): Photo {
        data = typeof data === 'object' ? data : {};
        let result = new Photo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["propertyId"] = this.propertyId;
        data["isDefault"] = this.isDefault;
        data["isDeleted"] = this.isDeleted;
        data["deletedDateTime"] = this.deletedDateTime ? this.deletedDateTime.toISOString() : <any>undefined;
        data["property"] = this.property ? this.property.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPhoto {
    id: number;
    url: string;
    propertyId: number;
    isDefault: boolean;
    isDeleted: boolean;
    deletedDateTime?: Date | undefined;
    property: Property;
}

export class PropertyViewModel implements IPropertyViewModel {
    model!: PropertyModel;
    gridModel!: PropertyGridModel;
    optionsDataSources!: any;

    constructor(data?: IPropertyViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.model = new PropertyModel();
            this.gridModel = new PropertyGridModel();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.model = _data["model"] ? PropertyModel.fromJS(_data["model"]) : new PropertyModel();
            this.gridModel = _data["gridModel"] ? PropertyGridModel.fromJS(_data["gridModel"]) : new PropertyGridModel();
            this.optionsDataSources = _data["optionsDataSources"];
        }
    }

    static fromJS(data: any): PropertyViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        data["gridModel"] = this.gridModel ? this.gridModel.toJSON() : <any>undefined;
        data["optionsDataSources"] = this.optionsDataSources;
        return data;
    }
}

export interface IPropertyViewModel {
    model: PropertyModel;
    gridModel: PropertyGridModel;
    optionsDataSources: any;
}

export class PropertyModel implements IPropertyModel {
    id!: number;
    name!: string;
    sellRent!: number;
    propertyTypeId!: number;
    furnishingTypeId!: number;
    bhk!: number;
    price!: number;
    buildArea!: number;
    carpetArea!: number;
    floorNo!: number;
    totalFloor!: number;
    addressId!: number;
    isReadyToMove!: boolean;
    mainEntrance!: string;
    security!: number;
    isGated!: boolean;
    maintenence!: number;
    estPossessionOn?: Date | undefined;
    postedOn?: Date | undefined;
    age!: number;
    description!: string;
    userId!: string;

    constructor(data?: IPropertyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sellRent = _data["sellRent"];
            this.propertyTypeId = _data["propertyTypeId"];
            this.furnishingTypeId = _data["furnishingTypeId"];
            this.bhk = _data["bhk"];
            this.price = _data["price"];
            this.buildArea = _data["buildArea"];
            this.carpetArea = _data["carpetArea"];
            this.floorNo = _data["floorNo"];
            this.totalFloor = _data["totalFloor"];
            this.addressId = _data["addressId"];
            this.isReadyToMove = _data["isReadyToMove"];
            this.mainEntrance = _data["mainEntrance"];
            this.security = _data["security"];
            this.isGated = _data["isGated"];
            this.maintenence = _data["maintenence"];
            this.estPossessionOn = _data["estPossessionOn"] ? new Date(_data["estPossessionOn"].toString()) : <any>undefined;
            this.postedOn = _data["postedOn"] ? new Date(_data["postedOn"].toString()) : <any>undefined;
            this.age = _data["age"];
            this.description = _data["description"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): PropertyModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sellRent"] = this.sellRent;
        data["propertyTypeId"] = this.propertyTypeId;
        data["furnishingTypeId"] = this.furnishingTypeId;
        data["bhk"] = this.bhk;
        data["price"] = this.price;
        data["buildArea"] = this.buildArea;
        data["carpetArea"] = this.carpetArea;
        data["floorNo"] = this.floorNo;
        data["totalFloor"] = this.totalFloor;
        data["addressId"] = this.addressId;
        data["isReadyToMove"] = this.isReadyToMove;
        data["mainEntrance"] = this.mainEntrance;
        data["security"] = this.security;
        data["isGated"] = this.isGated;
        data["maintenence"] = this.maintenence;
        data["estPossessionOn"] = this.estPossessionOn ? this.estPossessionOn.toISOString() : <any>undefined;
        data["postedOn"] = this.postedOn ? this.postedOn.toISOString() : <any>undefined;
        data["age"] = this.age;
        data["description"] = this.description;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IPropertyModel {
    id: number;
    name: string;
    sellRent: number;
    propertyTypeId: number;
    furnishingTypeId: number;
    bhk: number;
    price: number;
    buildArea: number;
    carpetArea: number;
    floorNo: number;
    totalFloor: number;
    addressId: number;
    isReadyToMove: boolean;
    mainEntrance: string;
    security: number;
    isGated: boolean;
    maintenence: number;
    estPossessionOn?: Date | undefined;
    postedOn?: Date | undefined;
    age: number;
    description: string;
    userId: string;
}

export class UpsertPropertyCommand extends PropertyModel implements IUpsertPropertyCommand {

    constructor(data?: IUpsertPropertyCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpsertPropertyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertPropertyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpsertPropertyCommand extends IPropertyModel {
}

export class PropertyTypeGridModel implements IPropertyTypeGridModel {
    id!: number;
    name!: string;

    constructor(data?: IPropertyTypeGridModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PropertyTypeGridModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyTypeGridModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IPropertyTypeGridModel {
    id: number;
    name: string;
}

export class PropertyTypeViewModel implements IPropertyTypeViewModel {
    model!: PropertyTypeModel;
    gridModel!: PropertyTypeGridModel;

    constructor(data?: IPropertyTypeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.model = new PropertyTypeModel();
            this.gridModel = new PropertyTypeGridModel();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.model = _data["model"] ? PropertyTypeModel.fromJS(_data["model"]) : new PropertyTypeModel();
            this.gridModel = _data["gridModel"] ? PropertyTypeGridModel.fromJS(_data["gridModel"]) : new PropertyTypeGridModel();
        }
    }

    static fromJS(data: any): PropertyTypeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyTypeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        data["gridModel"] = this.gridModel ? this.gridModel.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPropertyTypeViewModel {
    model: PropertyTypeModel;
    gridModel: PropertyTypeGridModel;
}

export class PropertyTypeModel implements IPropertyTypeModel {
    id!: number;
    name!: string;

    constructor(data?: IPropertyTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PropertyTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IPropertyTypeModel {
    id: number;
    name: string;
}

export class UpsertPropertyTypeCommand extends PropertyTypeModel implements IUpsertPropertyTypeCommand {

    constructor(data?: IUpsertPropertyTypeCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpsertPropertyTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpsertPropertyTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpsertPropertyTypeCommand extends IPropertyTypeModel {
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}